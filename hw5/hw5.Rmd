---
title: "hw5"
author: "Team 6 - Radhika Anand, Sophie Lee, Minjung Park, Kungang Zhang"
date: "11/10/2014"
output: html_document
---


```{r}
#Load necessary packages first!
source("check_packages.R")
check_packages(c("parallel","xtable", "doMC", "foreach", "truncnorm", "iterators")) 
```

In this assignment, we test the time difference between the single core and the multicore, required for running four samplers. 

#### Samplers 

The four samplers constructed in testing the running time for single core and multi core are as follows. 


# 1. Rejection sampling

Strategy
1. We first sample uniformly from the X axis -- this is the x value of the envelop density. Since each test distribution functions specified ranges, the X values for the envelop function is (min(range), max(range)). With the X values, we create an envelope function which is greater than or equal to the target distribution we wish to sample from at all points. 
2. Density function for Uniform distribution is generated. Using the max and min values of the density function, sample Ys from uniform as well.
3. Throw away the Y value if it's over the value drawn from the density function and keep the rest.

```{r}

reject = function(n, dfunc, range, mc){ 
  stopifnot(is.function(dfunc))
  stopifnot(is.numeric(n))
  stopifnot(is.logical(mc))
  stopifnot(is.vector(range))

  if(mc==FALSE){
    mc=1
  } else{
    if(n>10000)
    {
      mc=8
    } else{
      mc=2
    }
  }
  
  ## 1) generate values of Xs and Ys from uniform
 
  rejection=function(n,dfunc,range,mc){  
    proposal_x=runif(n, min(range), max(range))    
  
    ## 2) reject if Y is larger than the value from dfunc
    result_x=rep(0,n)
    result_x[1]=proposal_x[1]
    for(i in 2:n) {
      x=proposal_x[i]      
      y=dfunc(x) #target dist. evaluated at x
      ratio=y/1 # calculate the ratio  (density of unif. evaluated at x =1)
      if(runif(1,0,1)<ratio){ 
        result_x[i]=x
      } else{result_x[i]=result_x[i-1]} # end of acceptance condition
    } #end of rejection for loop
    return(result_x)
  }
  
  vec=unlist(mclapply(1:mc, function(x) rejection(ceiling(n/mc),dfunc,range,mc),mc.cores=mc))
  vec=vec[1:n]
  return(vec)
  
}  # end of function: reject

```

#Score table for rejection sampler when n = 1,000,000
The code to generate the following table is included in the reject.R file, which is saved under hw5 directory. 

```{r}
load("score_reject_data.Rdata")
options(warn=-1)
x=xtable(score_reject_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```

# Singlecore - Rejection sampler
The code to generate the following table is included in the reject.R file, which is saved under hw5 directory. 

```{r}
load("reject_data.Rdata")
options(warn=-1)
x=xtable(reject_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```
# Multicore - Rejection sampler

```{r}
load("reject_data_T.Rdata")
options(warn=-1)
x=xtable(reject_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```





### 2. Metropolis Hastings sampling



### 3. Slice sampling

#Algorithm
The paper ``Radford Neal, the annals of stat., 03-slice sampling" shows a way to sample under the area of pdf function. The algorithm is as follows.

1) Starting from the support regime of the density function $df(x)$, outside which the value of the function is only zero, uniformly draw one sample $x_0$ from that regime.
2) Find the $df(x_0)$ and uniformly draw one sample from [$0$,$df(x_0)$] giving $y_0$.
3) Draw a horizontal line, and find the smallest regime where $df(x)>y_0$. And uniformly draw on sample from that regime giving $x_1$.
4) Draw a sample from vertical line segment [$0$,$df(x_1)$] giving $y_1$.
5) Repeat step 3) and 4) until the sample size of $\{x_i\}$ reaches given value.

##Realization
In step 3), finding a horizontal line segment with two end points giving $df(x_{left,i})=df(x_{right,i})=y_i$ is not easy. We need set a step length $w$. Starting from $x_i$, expand the regime in that step length in both direction while checking if the end points have reached outside of density curve. 

There is one problem in the fixed step length. If there exists a infinitly sharp mode, meaning the width of the tip goes to zero, $w$ may not well capture the regime at very narrow place. Then, if $x_i$ falls outside of that regime, we need to reject it and re-draw. The slice sampling can get stuck at this rejection sampling for extremely long time. To solve this problem, a threshold number for iteration in rejection sampling is set. 


```{r}

slice = function(n, dfunc, range, mc){
  stopifnot(is.function(dfunc))
  stopifnot(is.numeric(n))
  stopifnot(is.logical(mc))
  stopifnot(is.vector(range))
  
  if(mc==FALSE){
    mc=1
  } else{
    if(n>10000)
    {
      mc=8
    } else{
      mc=2
    }
  }
  
  check<-function(x)
  {
    if (is.finite(x) & is.numeric(x)) return(0)
    else
    {
      if (is.na(x)==TRUE) return(1)
      else
      {
        if (is.nan(x)==TRUE) return(2)
        else 
        {
          if ((is.infinite(x)==TRUE)) return(3)
          else return(4)
        }
      }
    }
  }
  
  sampling<-function(nc,dfunc,range,cores) 
  {
    rangec=range
    res<-matrix(NA,n,ncol=1,nrow=nc)
    w=abs(rangec[1]-rangec[2])/10
    y=0
    for (i in 1:nc)
    {
      res[i]=runif(1,rangec[1],rangec[2])
#       stopifnot(check(res[i])==0)
#       stopifnot(check(dfunc(res[i]))==0)
      k=0
      kk=0
      while (dfunc(res[i])<y) 
      {
        if (res[i]<res[i-1])
        {
          rangec[1]=res[i]
        }
        else
        {
          if (res[i]>res[i-1])
          {
            rangec[2]=res[i]
          }
        }
        res[i]=runif(1,rangec[1],rangec[2])
#         stopifnot(check(res[i])==0)
#         stopifnot(check(dfunc(res[i]))==0)
        k=k+1
        if(k>10)
        {
          kk=kk+1
         # print(c(k,kk,res[i],cores))
          rangec=range
          res[i]=runif(1,rangec[1],rangec[2])
#           stopifnot(check(res[i])==0)
#           stopifnot(check(dfunc(res[i]))==0)
          break
        }
      }
      y=runif(1,0,dfunc(res[i]))
      rangec=rep(res[i],2)
      while (dfunc(rangec[1])>y)
      {
        rangec[1]=rangec[1]-w
      }
      while (dfunc(rangec[2])>y)
      {
        rangec[2]=rangec[2]+w
      }
    }
    return(res)
  }
  
  cores=mc
  nc=ceiling(n/cores)
  sample<-unlist(mclapply(1:cores, function(z) sampling(nc,dfunc,range,cores),mc.cores = cores))
  sample=sample[1:n]
  return(sample)
}

```

# Score table for slice sampler when n = 1,000,000
The code to generate the following table is included in the slice.R file, which is saved under hw5 directory. 

```{r}
load("score_slice_data.Rdata")
options(warn=-1)
x=xtable(score_slice_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```

# singlecore - Slice sampler
The code to generate the following table is included in the slice.R file, which is saved under hw5 directory. 
```{r}
load("slice_data.Rdata")
options(warn=-1)
x=xtable(slice_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```
# multiore - Slice sampler
```{r}
load("slice_data_T.Rdata")
options(warn=-1)
x=xtable(reject_data, type="html", digits=3)
options(warn=0)
```
```{r table,results='asis'}
print.xtable(x,type="html")
```




# 4. R sampling



```{r}

```





