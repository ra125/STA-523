---
title: "hw5"
author: "Team 6 - Radhika Anand, Sophie Lee, Minjung Park, Kungang Zhang"
date: "11/10/2014"
output: html_document
---


```{r}
#Load necessary packages first!
source("check_packages.R")
check_packages(c("parallel","xtable", "doMC", "foreach", "truncnorm", "iterators")) 
```

In this assignment, we test the time difference between the single core and the multicore, required for running four samplers. In doing so, the following six distribution functions and the scoring function given are used. 

### Test distributions

```{r}

#beta 0.9, 0.9
dbetann = function(x)
{
  dbeta(x,0.9,0.9)
}

#truncated normal
dtnorm = function(x)
{
  ifelse(x < -3 | x > 3, 0, dnorm(x)/0.9973002)
}

#truncated exponential
dtexp = function(x)
{
  ifelse(x < 0 | x > 6, 0, dexp(x, rate=1/3)/0.8646647)
}
  
#uniform mixture
dunif_mix = function(x)
{
  ifelse(x >= -3 & x < -1, 0.6*dunif(x,-3,-1),
         ifelse(x >= -1 & x <  1, 0.1*dunif(x,-1, 1),
                ifelse(x >=  1 & x <  4, 0.3*dunif(x, 1, 4), 
                       0)))
}

#truncated normal mixture 1
dtnorm_mix1 = function(x)
{
  ifelse(x < 0 | x > 10, 
         0, 
         ( 0.5*dnorm(x,mean=2,sd=2)
           +0.5*dnorm(x,mean=6,sd=1))/0.90059152)
}

#truncated normal mixture 2
dtnorm_mix2 = function(x)
{
  ifelse(x < -4 | x > 4, 
         0, 
         ( 0.45*dnorm(x,mean=-4)
           +0.45*dnorm(x,mean= 4)
           +0.1 *dnorm(x,mean= 0,sd=0.5))/0.4999683)
}

```

### Scoring function

```{r}
score = function(x, dfunc) 
{
  stopifnot(is.numeric(x) & length(x))
  
  x = sort(x)
  n = length(x)
  
  ex = ecdf(x)(x)
  
  dx = dfunc(x)
  ed = cumsum(c(0, (x[-1]-x[-n])*(dx[-1]+dx[-n])/2))
  
  return( sqrt(sum((ex-ed)^2)/n) )
}



```


#### Samplers 

The four samplers constructed in testing the running time for single core and multi core are as follows. 


# 1. Rejection sampling

Strategy
1. sample uniformly from the X axis -- this is the envelop density. Since each test distribution functions specified ranges, the envelop function is Unifrom (min(range), max(range)). This is to create an envelope function which is greater than or equal to the target distribution we wish to sample from at all points, and which we can sample from easily.
2. Using the max and min values of the density function, sample Ys from uniform as well.
3. Throw away the Y value if it's over the value drawn from the density function and keep the rest.

```{r}

reject = function(n, dfunc, range, mc){ 
  stopifnot(is.function(dfunc))
  stopifnot(is.numeric(n))
  stopifnot(is.logical(mc))
  stopifnot(is.vector(range))

  if(mc==FALSE){
    mc=1
  } else{
    if(n>10000)
    {
      mc=8
    } else{
      mc=2
    }
  }
  
  ## 1) generate values of Xs and Ys from uniform
 
  rejection=function(n,dfunc,range,mc){  
    proposal_x=runif(n, min(range), max(range))
    ys<-dfunc(x=proposal_x)
    proposal_y<-runif(n, min=min(ys), max=max(ys)) #envelop function
    
    
  ## 2) reject if Y is larger than the value from dfunc
    result_x=rep(0,n)
    result_x[1]=proposal_x[1]
    for(i in 2:n) {
      x=proposal_x[i]      
      y=dfunc(x) #target dist. evaluated at x
      proposal_int=proposal_y[i] #envelop dist. evaluated at x
      ratio=y/proposal_int # calculate the ratio
      if(runif(1,0,1)<ratio){ 
        result_x[i]=x
      } else{result_x[i]=result_x[i-1]} # end of acceptance condition
    } #end of rejection for loop
    return(result_x)
  }
  
  vec=unlist(mclapply(1:mc, function(x) rejection(ceiling(n/mc),dfunc,range,mc),mc.cores=mc))
  vec=vec[1:n]
  return(vec)
  
}  # end of function: reject

```

#Score table for rejection sampler when n = 1,000,000
The code to generate the following table is included in the reject.R file, which is saved under hw5 directory. 

```{r}
load("score_reject_data.Rdata")
options(warn=-1)
xtable(score_reject_data, type="html", digits=3)
options(warn=0)
```

## Running time table for rejection sampler
The code to generate the following table is included in the reject.R file, which is saved under hw5 directory. 

# Singlecore - Rejection sampler

```{r}
load("reject_data.Rdata")
options(warn=-1)
xtable(reject_data, type="html", digits=3)
options(warn=0)
```

# Multicore - Rejection sampler

```{r}
load("reject_data_T.Rdata")
options(warn=-1)
xtable(reject_data, type="html", digits=3)
options(warn=0)

```





### 2. Metropolis Hastings sampling



### 3. Slice sampling

#Algorithm
The paper ``Radford Neal, the annals of stat., 03-slice sampling" shows a way to sample under the area of pdf function. The algorithm is as follows.

1) Starting from the support regime of the density function $df(x)$, outside which the value of the function is only zero, uniformly draw one sample $x_0$ from that regime.
2) Find the $df(x_0)$ and uniformly draw one sample from [$0$,$df(x_0)$] giving $y_0$.
3) Draw a horizontal line, and find the smallest regime where $df(x)>y_0$. And uniformly draw on sample from that regime giving $x_1$.
4) Draw a sample from vertical line segment [$0$,$df(x_1)$] giving $y_1$.
5) Repeat step 3) and 4) until the sample size of $\{x_i\}$ reaches given value.

##Realization
In step 3), finding a horizontal line segment with two end points giving $df(x_{left,i})=df(x_{right,i})=y_i$ is not easy. We need set a step length $w$. Starting from $x_i$, expand the regime in that step length in both direction while checking if the end points have reached outside of density curve. 

There is one problem in the fixed step length. If there exists a infinitly sharp mode, meaning the width of the tip goes to zero, $w$ may not well capture the regime at very narrow place. Then, if $x_i$ falls outside of that regime, we need to reject it and re-draw. The slice sampling can get stuck at this rejection sampling for extremely long time. To solve this problem, a threshold number for iteration in rejection sampling is set. Above this threhold, the sampling would start with the original range. This would results in some smoothness in the sharp modes. However, even though we use adaptive step width $w$, the sampling profile wouldn't be infinitely sharp. 


```{r}

slice = function(n, dfunc, range, mc){
  stopifnot(is.function(dfunc))
  stopifnot(is.numeric(n))
  stopifnot(is.logical(mc))
  stopifnot(is.vector(range))
  
  if(mc==FALSE){
    mc=1
  } else{
    if(n>10000)
    {
      mc=8
    } else{
      mc=2
    }
  }
  
  check<-function(x)
  {
    if (is.finite(x) & is.numeric(x)) return(0)
    else
    {
      if (is.na(x)==TRUE) return(1)
      else
      {
        if (is.nan(x)==TRUE) return(2)
        else 
        {
          if ((is.infinite(x)==TRUE)) return(3)
          else return(4)
        }
      }
    }
  }
  
  sampling<-function(nc,dfunc,range,cores) 
  {
    rangec=range
    res<-matrix(NA,n,ncol=1,nrow=nc)
    w=abs(rangec[1]-rangec[2])/10
    y=0
    for (i in 1:nc)
    {
      res[i]=runif(1,rangec[1],rangec[2])
#       stopifnot(check(res[i])==0)
#       stopifnot(check(dfunc(res[i]))==0)
      k=0
      kk=0
      while (dfunc(res[i])<y) 
      {
        if (res[i]<res[i-1])
        {
          rangec[1]=res[i]
        }
        else
        {
          if (res[i]>res[i-1])
          {
            rangec[2]=res[i]
          }
        }
        res[i]=runif(1,rangec[1],rangec[2])
#         stopifnot(check(res[i])==0)
#         stopifnot(check(dfunc(res[i]))==0)
        k=k+1
        if(k>10)
        {
          kk=kk+1
         # print(c(k,kk,res[i],cores))
          rangec=range
          res[i]=runif(1,rangec[1],rangec[2])
#           stopifnot(check(res[i])==0)
#           stopifnot(check(dfunc(res[i]))==0)
          break
        }
      }
      y=runif(1,0,dfunc(res[i]))
      rangec=rep(res[i],2)
      while (dfunc(rangec[1])>y)
      {
        rangec[1]=rangec[1]-w
      }
      while (dfunc(rangec[2])>y)
      {
        rangec[2]=rangec[2]+w
      }
    }
    return(res)
  }
  
  cores=mc
  nc=ceiling(n/cores)
  sample<-unlist(mclapply(1:cores, function(z) sampling(nc,dfunc,range,cores),mc.cores = cores))
  sample=sample[1:n]
  return(sample)
}

```

# Score table for slice sampler when n = 1,000,000
The code to generate the following table is included in the slice.R file, which is saved under hw5 directory. 

```{r}
load("score_slice_data.Rdata")
options(warn=-1)
xtable(score_slice_data, type="html", digits=3)
options(warn=0)

```

## Running time table for slice sampler
The code to generate the following table is included in the slice.R file, which is saved under hw5 directory. 

# singlecore - Slice sampler
```{r}
load("slice_data.Rdata")
options(warn=-1)
xtable(slice_data, type="html", digits=3)
options(warn=0)
```
# multiore - Slice sampler
```{r}
load("slice_data_T.Rdata")
options(warn=-1)
xtable(reject_data, type="html", digits=3)
options(warn=0)

```



# 4. R sampling




```{r}

```




dbetann:


```{r}

```


```{r}

```



