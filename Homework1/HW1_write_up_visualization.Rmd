---
title: "Write up"
author: "Sophie Lee"
date: "September 17, 2014"
output: html_document
---
Task 1: Parsing
The parsing process consists of four steps: 1. Extracting categorical names for column names; 2. Extracting content for each column name by designing matching patterns, so that common features of these categories can be used; 3. Excluding unwanted entries by using subsetting; 4. Pre-process the data for distance calculation. The data frame ready to be used is "dat.scr" with original columns and newly added columns replacing some older ones (i.e. "style", "pig").

1.
By using the first row of data, the categorical names can be extracted by applying matching condition “ ([a-z]*)=”, because the column names are outside of double quote, and followed with a “=”. Using “str_match_all” can return all those categorical names for future column names.

2.
The contents of those categories have some common features: (1) Before the “”, there is a “ “ and a categorical name followed by a “=”.By using function “paste”, I can concatenate those patterns together, with a vector entry “c_name.sorted[i]”, so that “for” loop can be used to run across columns. This can make code more concise. (2) They all are enclosed by “”, within which there are no “, so we can use "=\"([^\"]*)\"" as matching pattern inside “”. (3) Neighboring categories are separated by “ “, so that we can specify sep=” “. Using “str_match” instead of “str_match_all” can return the one content corresponding to that categorical name. 

3.
During “for” loop, the “flag.na” is used to match the NA entries. After “for” loop, “ispen” of “class” column and “Own goal” of “ptype” column are matched. Those index are returned and used to generate a vector to subset valid rows. 

4. Some data are not ready to use, for example, “pig”, “style”. First, their type are not numeric, so that directly calculation by referring them would report errors. Second, some of them are not simple enough, because in “style”, three categories are enclosed, and “right” or “left” are not completed. Matching them, and adding them as columns to dataset, with more processing, make the dataset ready to be used.  


Task 2: Visulization

The graphs we generate, as part of the visualization task, summarize the information of the goals scored by the final four countries: Germany (champion), Argentina (runner up), Netherlands (third place), and Brazil (fourth place). Represented by its own flag, each country graph shows the length of goals and the time (in minutes) at which the goal was scored, as well as the name of the goaler.

ASSUMPTION (after looking at the source code of the data): To find the length of each goal, we assume the field length to be 0 to 1000 pixels (on the screen) and the goal-post length to be 100 pixels (from 450 to 550 pixels in the field). Next we use pig and style to calculate goal length.
. 
We believe that we can figure out each team’s strengths and weaknesses by comparing the patterns of goal distances by time. 

As we can see from the 4 visualizations, Germany (the champion) scores the most goals among the four countries. Relatively, most of goals were made in the first half and were mid-ranged (not too long, not too short) It is clear that Germany adopted a very attacking strategy.

On the other hand, even though Argentina scored the least goals (amongst the 4), it made its way up as a good defensive team. It didn’t let its opponents score too and hence was the runner ups. Also, most of Argentina’s goals were long-ranged.

Next, we see that Netherlands scores most of its goals in the second half of the game. This implies that Netherlands would never give up and is very capable of getting back towards the finishing time.

Brazil made its goals in various ranges and times. They have some long and some short goals and there is no striking trend in the time at which they score goals. This could also be true because one of their players was injured and the other was penalized in the semi-finals (the period for which we are making our visualizations)




```{r}

```

