---
title: "hw3_draft"
author: "Sophie Lee"
date: "10/12/2014"
output: html_document
---



```{r}
###### Task 1  (Geocoding)

#Load necessary packages
source("check_packages.R")
check_packages(c("data.table","ggmap","rgdal","maptools", "dplyr","stringr","lubridate"))
rm(check_packages)  #Remove anything that could take up memory

#Load the Biggish NYC parking violations datafile
park = fread("/home/vis/cr173/Sta523/data/parking/NYParkingViolations.csv",sep=",")
park<-park[park$'Violation County'=="NY",] #Filtering only NY for Manhattan
park$'Issue Date'=mdy(park$'Issue Date') 
colnames(park$'Issue Date')="Issue.Date" 
park<-filter(park, Issue.Date>"2013-07-31", Issue.Date<"2014-07-01") #Filtering the correct dates

#Extract the necessary variables
precinct<-as.numeric(park$"Violation Location")
address<-paste(park$"House Number", park$"Street Name")
street<-park$"Street Name"
cross<-park$"Intersecting Street"
street<-str_trim(street, side = "right")
cross<-str_trim(street, side = "left")
streets<-paste(street,":",cross)

#Create a new dataframe with necessary variables
d=data.frame("precinct"=as.numeric(precinct), 
             "address"=address, 
             "street"=street,
             "cross"=cross,
             "streets"=streets)

d=d[d$]

#Remove the original data frame and the temporary var names to save memory
rm(house_street)
rm(precinct)
rm(address)
rm(street)
rm(cross)
rm(park)


#Load 'pluto' data to geocode
basepath<-getwd()
setwd("/home/vis/cr173/Sta523/data/parking/pluto/Manhattan/")
pluto<-readShapeSpatial("MNMapPLUTO")
pluto_shape<-pluto

# plot(pluto, axes=TRUE)  ### If you wanna see what the data looks like..
pluto<-data.frame("address"=pluto$Address, 
                    "precinct"=pluto$PolicePrct, 
                    coordinates(pluto)) 
setwd(basepath)
rm(basepath)


#### We exlude observations that are not associated with the correct Manhattan precincts (1:34)
d<-d[which(d[,1] < 35),]
pluto<-pluto[which(pluto$precinct<35 & pluto$precinct>0),]




################ DO NOT RUN BELOW HERE ########################

# 
# 
# lat=lon=NULL
# names=d$address
# for(i in 1:length(names)) {
# if(pluto$address contain(names)
#   lat=pluto$X1
#   lon=pluto$X2
# 
#   lat=NA
# }
# 
# 
# 
# 
# 
# # Load 'ny borough' data
# basepath<-getwd()
# setwd("/home/vis/cr173/Sta523/data/parking/nybb")
# nyc<-readShapeSpatial("nybb")
# manhattan<-nyc[nyc$BoroName=="Manhattan",]
# setwd(basepath)
# rm(basepath)
# 
# 
# 
# man_int<-data.frame(man_int[,2])
# dir.create("data/", showWarnings = FALSE)
# save(d, file="data/d.csv")
# save(man_int, file="data/man_int.csv")
# 
# d[1:10,]
# length(unique(d[,2]))
# man_int[1:10,]
# length(unique(man_int$streets))
# 
# 
# names=d[,2]
# coord1=coord=rep(NA, length(names))
# 
# for(1 in 1:length(names)){
#   if (names==man_int$streets)
#      coord1<-man_int[,2] 
#      coord2<-man_int[,3]
#   }    
# 
# 
# 
# 
# # Load 'intersection' data to geocode
# basepath<-getwd()
# setwd("/home/vis/cr173/Sta523/data/parking/intersections")
# intersections<-readShapeSpatial("intersections")
# setwd(basepath)
# rm(basepath)
# 
# ### We could plot the map of Manhattan if we want
# # par(mar=c(2,2,1,1))
# # plot(nyc, axes=TRUE)
# # plot(manhattan, axes=TRUE)
# 
# ###### Since the intersection data has too many addresses, we subset the intersection data using the max and min of the longitude and lattitude of Manhattan.
# # 
# # minmax<-unlist(summary(manhattan)[2])
# # no=which(coordinates(intersections)[,1]>minmax[1] & 
# #          coordinates(intersections)[,1]<minmax[3] & 
# #          coordinates(intersections)[,2]>minmax[2] & 
# #          coordinates(intersections)[,2]<minmax[4] )
# # 
# # man_int=intersections[no,]  #observations in intersections data associated with manhattan addresses only
# 
# ## We could plot the coordinates of the remainder.
# # plot(man_int, axes=TRUE)
# 
# # Again, remove all the unnecessary temporary variable names.
# # rm(nyc)
# # rm(intersections)
# # rm(minmax)
# # rm(no)
# 
# 
# 
# 
# 
# ### we only work with address and precinct from now. rm all other data frame that takes up RAM space!
# ###geocode has 2500 requests limit a day
# 
# 
# # howmany <-1:100
# # howmany<-sample(1:length(address),2500,replace=FALSE)
# # howmany<-c(1:length(address))
# # 
# # latlon<-geocode(address[howmany], 
# #         output="latlon", 
# #         override_limit=FALSE) #geocode requires 'ggmap'
# # 
# # d<-cbind(latlon,precinct)
# # d[1:10,]
# # 
# # rm(address)
# # rm(precinct)
# # rm(howmany)
# 
# 
# ######## Subsetting -- We will use 95% of the datapoints
# q_lon<-matrix(quantile(d$lon, probs=c(0.025, 0.975), na.rm=TRUE))
# q_lat<-matrix(quantile(d$lat, probs=c(0.025, 0.975), na.rm=TRUE))
# pres<-(which( q_lon[1,1]< d$lon & d$lon<q_lon[2,1] & q_lat[1,1]< d$lat & d$lat<q_lat[2,1]))
# data<-d[pres,]
# 
# 
# ######## Now, the subsetted data is called "d"  Remove all else
# rm(d)
# rm(q_lon)
# rm(q_lat)
# rm(pres)
# 
# 
# 
# 
# ##### Plot the latitudes and longitudes in Manhattan
# 
# 
# ###### Save the objects as multipoints
# coord = SpatialPoints(data.frame(latlon)) 
# 
# 
# 
# ######## Recreating the boundary as GeoJson
# 
# 
# 
# 
# 
# 
# 
# 
# ######## Comparison
# 
# library(rgdal)
# 
# # To read GeoJSON must use OGRGeoJSON as layer
# p = readOGR("precinct_in.json","OGRGeoJSON") 
# 
# # Include precinct IDs as data with column named `precinct`
# p@data
# 
# 
# # Write to GeoJSON
# writeOGR(p, "./out", "", driver="GeoJSON") # Creates out file, current version of 
#                                            # GDAL does not allow . in file names 
#                                            # so we have to rename the file afterwards
# file.rename("./out", "./precinct.json")
# 
# p2 = readOGR("precinct.json","OGRGeoJSON") 
# 
# p2@data
# 
# 
# # Compare results
# pdf("plot.pdf",width=10,height=5)
# 
# par(mfrow=c(1,2))
# 
# # alpha affects alpha blending (makes things transparent), useful if polys may overlap
# plot(p,main = "precinct_in.json", axes=TRUE, col=adjustcolor(2:6,alpha=0.5))
# plot(p2,main = "precinct.json", axes=TRUE, col=adjustcolor(2:6,alpha=0.5))
# 
# # dev.off()

```



