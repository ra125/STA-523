---
title: "is_valid"
author: "Team 6"
date: "10/31/2014"
output: html_document
---
#fuction 2: is_valid (Sophie)
## Validate the graph object to ensure that it meets all requirements - 
#Check that object is a list of lists. Check if there are names for the primary list that they are all unique. 
#Check that each secondary list contains only edges and weights vectors that are of the appropriate type. 
#Check that there are not any edges to non-existent vertices. 
#Check that all weights are not less than or equal to 0. 
#Check that every edge has a weight.#If no weight, is it still valid?

```{r}

library(testthat)
library(methods)


```

### Function

```{r}

is_valid=function(input){

# Testing if the input has a list object

if(as.character(typeof(input[[1]])=="list")=="TRUE"){
  t1<-TRUE
}
  else {
  t1<-FALSE
  }

# Testing if the names of the lists in object are all unique

if(as.character( length(names(input[1]))==length(input)) =="TRUE"){
  t2<-TRUE
}
else{
  t2<-FALSE
}

 # Testing if the object has both weights and edges as lists

if(as.character( sum(grep("weights",names(input[[1]])))>0 & sum(grep("edges",names(input[[1]])))>0 )=="TRUE"){
  t3<-TRUE
}
else{
  t3<-FALSE
}

 # Testing if the types of edges are integer and weights are double

if(as.character(  typeof(input[[1]]$edges)=="integer" & typeof(input[[1]]$weights)=="double")=="TRUE"){
   t4<-TRUE
 }
else{
  t4<-FALSE
}

#5: Testing if there are not any edges to non-existent vertices. 
n=length(input)
result=list()
frame=NULL
for(i in 1:n){
result[i]<-exists("edges", where=input[[i]])
frame=data.frame(table(c(frame, result[[i]])))
no=c(frame[which(frame[,1]=="TRUE"),2])
}

if(length(no) > 0){  # begin First ifelse
    
    temp=NULL
    t_obj5_1=list()
    t_obj5_2=(1:n)
              for(i in 1:n){
              t_obj5_1[[i]]<-input[[i]]$edges
              temp=c(temp, t_obj5_1[[i]])
              } 
   
   if(max(temp)>0){  ## begin Second ifelse
  # integer==(input[[unique(temp)]])==dim(input[[t_obj5_2]])
   t_obj5= as.character( length(order(unique(temp))) ==length(rep(1,length(t_obj5_2)) )  )  
                  }
             else{
             t_obj5=as.character(TRUE)
                  }  ## end Second ifelse 
   
  
        } 
  
else {
   t_obj5=as.character(FALSE) 
        }    # end First ifelse


  if( length(unique(t_obj5))==1 & unique(t_obj5)=="TRUE" ) {   ### begin Third ifelse
                                                          t5<-TRUE
                                                           }
                                                      else{
                                                        t5<-FALSE
                                                          }   ### end Third ifelse




# 6: Testing if the weights are greater than 0.
if(   typeof( length(input[[1]]$weights))=="integer"  ){


    if( length(input[[1]]$weights)==0 ){
                                     t6<-TRUE
                                     }
    
    else{
        
            t_obj6<-as.character(input[[1]]$weights>0)
            t_obj6_1 <-data.frame(table(t_obj6))
            t_obj6_2<-length(rep(1,t_obj6_1[which(t_obj6_1[,1]==TRUE),2] ))
  
            t_obj6_3<-length(input[[1]]$weights)
            if(t_obj6_2==t_obj6_3) {
                            t6<-TRUE
                            }
                        else{
                            t6<-FALSE                          
                            }
            
      }
  }

else{
  t6<-FALSE
    }

# 7: Testing if edges and weights have the same length
n=length(input)
t_obj7<-rep(NA,n)
for(i in 1:n){
t_obj7[i]<-length(input[[i]]$weights) == length(input[[i]]$edges)
t_obj7_1<-data.frame(table(t_obj7))
t_obj7_2<-t_obj7_1[which(t_obj7_1[,1]=="FALSE"),2]
}  

if (length(t_obj7_2) >0){
  t7<-FALSE
}
else{
  t7<-TRUE
}

#8: Testing if there are duplicate edges
n=length(input)
t_obj8<-rep(NA, n)
for(i in 1:n){
  t_obj8[i]<- length(unique(input[[i]]$edges)) == length(input[[i]]$edges)
  t_obj8_1 <-data.frame(table(t_obj8))
  t_obj8_2 <-t_obj8_1[which(t_obj8_1[,1]=="FALSE"),2]
}

if (length(t_obj8_2)>0)
  {
  t8<-FALSE
  }
else{
  t8<-TRUE
}
  
# Testing if the object passes all tests above
each<-cbind(t1,t2,t3,t4,t5,t6, t7, t8)
if(sum(which(each==FALSE))>0) {
  print(FALSE)
}
else{
  print(TRUE)
}
  print(each)  ## This should be removed before submission. For now, it shows the result of each test.
}



```



### Testing

```{r}
basepath<-getwd()
newpath<-paste0(basepath,"/tests")
setwd(newpath)
test_file("test_is_valid.R")
test_that(is_valid)
setwd(basepath)

```

In case you are trying each object, use the codes below. Create g1:g6 and bad_g1:g3 first.
```{r}
#good ones
 g1 = list(list(edges   = c(1L, 2L),
                 weights = c(1, 1)),
            list(edges   = c(1L, 2L),
                 weights = c(1, 1)))

  g2 = list(A = list(edges   = c(1L, 2L),
                     weights = c(1, 1)),
            B = list(edges   = c(1L, 2L),
                     weights = c(1, 1)))

  g3 = list(list(edges   = c(2L),
                 
                 weights = c(1)),
            list(edges   = c(1L),
                 weights = c(1)))

  g4 = list(list(edges   = integer(),
                 weights = numeric()))

  g5 = list(list(edges   = c(1L),
                 weights = c(1)))
  
  g6 = list(list(weights = c(1),
                 edges   = c(1L)))
            


#bad structure
 bad_g1 = list(list())
  bad_g2 = list(list(edges = 1L))
  bad_g3 = list(list(weights = 1))

#invalid vertex reference
  bad_g4 = list(list(edges   = c(1L, 2L),
                     weights = c(1, 1)))

  bad_g5 = list(list(edges   = c(1L, 2L),
                     weights = c(1, 1)),
                list(edges   = c(1L, 3L),
                     weights = c(1, 1)))
 bad_g6 = list(A = list(edges   = c(1L, 2L),
                        weights = c(1, 1)),
               A = list(edges   = c(1L, 2L),
                        weights = c(1, 1)))

#Edge type
bad_g7 = list(list(edges   = c(1),
                     weights = c(1)))  
  bad_g8 = list(list(edges   = c("A"),
                     weights = c(1)))  
  bad_g9 = list(list(edges   = c(NA+1L),
                     weights = c(1)))  
  #weight type and value
 bad_g10 = list(list(edges   = c(1L),
                     weights = c(-1)))
  bad_g11 = list(list(edges   = c(1L),
                     weights = c(0)))
  bad_g12 = list(list(edges   = c(1L),
                     weights = c(NA+1)))
#duplicate edge
 bad_g13= list(list(edges   = c(1L, 1L),
                  weights = c(1, 1)))

#edge and weights length mismatch
 bad_g14 = list(list(edges   = c(1L),
                     weights = c(1, 1)))
  bad_g15 = list(list(edges   = c(1L, 2L),
                     weights = c(1)))
  bad_g16 = list(list(edges   = c(1L, 2L),
                     weights = c(1, 1)),
                list(edges   = c(1L, 2L),
                     weights = c(1, 1, 1)))
  bad_g17 = list(list(edges   = c(1L, 2L),
                     weights = c(1, 1)),
                list(edges   = c(1L, 2L, 3L),
                     weights = c(1, 1)))


is_valid(g1)
is_valid(g2)
is_valid(g3) 
is_valid(g4)  
is_valid(g5)
is_valid(g6)


is_valid(bad_g1)
is_valid(bad_g2)
is_valid(bad_g3) 
is_valid(bad_g4) 
is_valid(bad_g5) 
is_valid(bad_g6) 
is_valid(bad_g7)
is_valid(bad_g8)
is_valid(bad_g9) # t5 Error in if (max(temp) > 0) { : missing value where TRUE/FALSE needed
is_valid(bad_g10) # t6 bug: Error in rep(1, t_obj6_1[which(t_obj6_1[, 1] == TRUE), 2]) :   invalid 'times' argument

is_valid(bad_g11) # t6 same bug as g10
is_valid(bad_g12) # t6 same bug as above
is_valid(bad_g13) 
is_valid(bad_g14) 
is_valid(bad_g15) 
is_valid(bad_g16) 
is_valid(bad_g17) 
```
